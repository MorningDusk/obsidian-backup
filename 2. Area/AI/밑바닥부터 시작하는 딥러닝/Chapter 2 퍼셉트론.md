---
tags:
  - perceptron
  - deep_learning
  - ai
date: 2025-06-26
---
# 1. 퍼셉트론이란?
**퍼셉트론**<sub>perceptron</sub>은 다수의 신호를 입력으로 받아 하나의 신호를 출력한다. 여기서 신호란 전류나 강류처럼 흐름이 있는 것이라고 보면 된다. 다만, 실제 전류와는 달리 신호는 ‘흐른다/안 흐른다’(1이나 0)의 두 가지 값을 가진다.
![[Pasted image 20250626212420.png]]
위는 입력으로 2개의 신호를 받은 퍼셉트론의 예이다. $x_1$과 $x_2$는 입력 신호, $y$는 출력 신호, $w_1$과 $w_2$는 가중치를 뜻한다. 원을 뉴런 혹은 노드라고 한다. 입력 신호가 뉴런에 보내질 때는 각각 고유한 가중치가 곱해진다($w_1x_1, w_2x_2$). 뉴런에서 보내온 신호의 총합이 정해진 한계를 넘어설 때만 1을 출력하는데 이것을 임계값이라고 하며 $\theta$로 나타낸다.
$$
y = \begin{cases} 0\ (w_1x_1 + w_2x_2 \leq \theta) \\ 1\ (w_1x_1+w_2x_2 > \theta) \end{cases}
$$
퍼셉트론은 복수의 입력 신호에 각각에 고유한 가중치를 부여한다. 가중치는 각 신호가 결과에 주는 영향력을 조절하는 요소로 작용한다.
# 2. 단순한 논리 회로
## 2.1. AND 게이트
**AND 게이트**는 입력이 둘이고 출력은 하나다. 입력 신호와 출력 신호의 대응 표를 **진리표**라고 하는데 두 입력이 모두 1일 때만 1을 출력하고 그 외에는 0을 출력한다.

| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 0   |
| 1     | 0     | 0   |
| 0     | 1     | 0   |
| 1     | 1     | 1   |
## 2.2. NAND 게이트와 OR 게이트
**NAND**는 **Not AND**를 의미하며, 그 동작은 AND 게이트의 출력을 뒤집은 것이 된다. $x_1$과 $x_2$가 모두 1일 때만 0을 출력하고 그 외에는 1을 출력한다.

| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 1   |
| 1     | 0     | 1   |
| 0     | 1     | 1   |
| 1     | 1     | 0   |
**OR 게이트**는 입력 신호 중 하나 이상이 1이면 출력이 1이 되는 논리 회로다.

| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 0   |
| 1     | 0     | 1   |
| 0     | 1     | 1   |
| 1     | 1     | 1   |
# 3. 퍼셉트론 구현하기
## 3.1. 간단한 구현부터
다음은 `x1`과 `x2`를 인수로 받는 AND라는 함수다.
``` python
def AND(x1, x2):
	w1, w2, theta = 0.5, 0.5, 0.7
	tmp = x1 * w1 + x2 * w2
	if tmp <= theta:
		return 0
	elif tmp > theta:
		return 1
```
매개변수 `w1`, `w2`, `theta`는 함수 안에서 초기화하고 가중치를 곱한 입력의 총합이 임계값을 넘으면 1을 반환하고 그 외에는 0을 반환한다.
``` python
AND(0, 0)  # 0을 출력 
AND(1, 0)  # 0을 출력
AND(0, 1)  # 0을 출력
AND(1, 1)  # 1을 출력
```
## 3.2. 가중치와 편향 도입
$$
y = \begin{cases} 0\ (b+w_1x_1 + w_2x_2 \leq 0) \\ 1\ (b+w_1x_1+w_2x_2 > 0) \end{cases}
$$
여기서 $b$를 **편향**(bias)이라 하며 $w_1$과 $w_2$는 그대로 가중치다. 여기서 퍼셉트론은 입력 신호에 가중치를 곱한 값과 편향을 합하여 그 값이 0을 넘으면 1을 출력하고 그렇지 않으면 0을 출력한다.
``` python
import numpy as np

x = np.array([0, 1])  # 입력
w = np.array([0.5, 0.5])  # 가중치
b = -0.7  # 편향
w*x
# array([0. , 0.5])
np.sum(w*x)
# 0.5
np.sum(w*x) + b
# -0.199999999999999996   대략 -0.2 (부동소수점 수에 의한 연산 오차)
```
넘파이 배열끼리의 곱셈은 두 배열의 원소 수가 같다면 각 원소끼리 곱한다. 그래서 이 예의 `w*x`에서는 인덱스가 같은 원소끼리 곱한다(`[0, 1] * [0.5, 0.5] → [0, 0.5]`). 또, `np.sum()` 메서드는 입력한 배열에 담긴 모든 원소의 총합을 계산한다.이 가중치에 편향을 더하면 계산이 완료된다.
## 3.3. 가중치와 편향 구하기
‘가중치와 편향을 도입’한 AND 게이트는 다음과 같다.
``` python
def AND(x1, x2):
	x = np.array([x1, x2])
	w = np.array([0.5, 0.5])
	b = -0.7
	tmp = np.sum(w*x) + b
	if tmp <= 0:
		return 0
	else:
		return 1
```
여기서 $-\theta$가 편향 $b$로 치환되었다. 또한 편향은 가중치 $w_1$, $w_2$와 기능이 다른데, $w_1$과 $w_2$는 각 입력 신호가 결과에 주는 영향력(중요도)을 조절하는 매개변수고, 편향은 뉴런이 얼마나 쉽게 활성화(결과로 1을 출력)하느냐를 조정하는 매개변수다. 예를 들어 $b$가 -0.1이면 각 입력 신호에 가중치를 곱한 값들의 합이 0.1을 초과할 때만 뉴런이 활성화한다. 하지만 $b$가 -20.0이면 각 입력 신호에 가중치를 곱한 값들의 합이 20.0을 넘지 않으면 뉴런을 활성화하지 않는다.
다음은 NAND 게이트와 OR 게이트를 구현한 코드다.
``` python
def NAND(x1, x2):
	x = np.array([x1, x2])
	w = np.array([-0.5, -0.5])  # AND와는 가중치(w와 b)만 다르다
	b = 0.7
	tmp = np.sum(w*x) + b
	if tmp <= 0:
		return 0
	else:
		return 1

def OR(x1, x2):
	x = np.array([x1, x2])
	w = np.array([0.5, 0.5])   # AND와는 가중치(w와 b)만 다르다
	b = -0.2
	tmp = np.sum(w*x) + b
	if tmp <= 0:
		return 0
	else:
		return 1
```
# 4. 퍼셉트론의 한계
## 4.1. XOR 게이트
**XOR 게이트**는 베타적 논리합이라는 논리 회로이다. $x_1$과 $x_2$ 중 한쪽이 1일 때만 1을 출력한다.

| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 0   |
| 1     | 0     | 1   |
| 0     | 1     | 1   |
| 1     | 1     | 0   |
하지만 퍼셉트론으로는 XOR 게이트를 구현할 수 없다. OR 게이트는, 예를 들어 가중치 매개변수가 $(b, w_1, w_2) = (-0.5, 1.0, 1.0)$일 때 OR 게이트 진리표를 만족한다. 이때 퍼셉트론 식은 다음과 같다.
$$
y = \begin{cases} 0\ (-0.5+x_1 + x_2 \leq 0 )\\ 1\ (0.5+x_1+x_2 > 0 )\end{cases}
$$

이 퍼셉트론은 직선으로 나뉜 두 영역을 만든다. 직선으로 나뉜 한쪽 영역은 1을 출력하고 다른 한쪽은 0을 출력한다.
![[Pasted image 20250626214704.png]]

여기서 OR 게이트는 $(x_1, x_2) = (0, 0)$일 때 0을 출력하고 $(0, 1), (1, 0), (1, 1)$일 때는 1을 출력한다. OR 게이트를 만들려면 🔵과 🔺을 직선으로 나눠야 한다.
![[Pasted image 20250626214754.png]]
하지만 XOR 게이트는 OR 게이트와는 다르게 직선 하나로 나누는 방법은 없다.
## 4.2. 선형과 비선형
직선 하나로 XOR 게이트를 나눌 수 없지만 ‘직선’이라는 제약을 없애면 가능하다.
![[Pasted image 20250626214815.png]]
이러한 곡선의 영역을 **비선형** 영역, 직선의 영역을 **선형** 영역이라고 한다.
# 5. 다층 퍼셉트론이 충돌한다면
하지만 퍼셉트론만으로 비선형 영역인 XOR 게이트를 표현할 수 없다. 그러나 층을 쌓은 **다층 퍼셉트론**(multi-layer perceptron)으로 구현이 가능하다.
## 5.1. 기존 게이트 조합하기
XOR 게이트를 만드는 방법은 다양한데, 그 중 하나는 AND, NAND, OR 게이트를 조합하는 방법이다. 일단 AND, NAND, OR 게이트를 다음과 같은 기호로 표기한다.
![[Pasted image 20250626214903.png]]
다음과 같은 조합이라면 XOR 게이트를 구현할 수 있다. $x_1$과 $x_2$가 입력 신호, $y$가 출력 신호이다. $x_1$과 $x_2$는 NAND와 OR 게이트의 입력이 되고, NAND와 OR의 출력이 AND 게이트의 입력으로 이어진다.
![[Pasted image 20250626214953.png]]

| $x_1$ | $x_2$ | $s_1$ | $s_2$ | $y_1$ |
| ----- | ----- | ----- | ----- | ----- |
| 0     | 0     | 1     | 0     | 0     |
| 1     | 0     | 1     | 1     | 1     |
| 0     | 1     | 1     | 1     | 1     |
| 1     | 1     | 0     | 1     | 0     |
## 5.2. XOR 게이트 구현하기
``` python
def XOR(x1, x2):
	s1 = NAND(x1, x2)
	s2 = OR(x1, x2)
	y = AND(s1, s2)
	return y
```
이 함수는 다음과 같은 결과를 출력한다.
``` python
XOR(0, 0)  # 0을 출력
XOR(1, 0)  # 1을 출력
XOR(0, 1)  # 1을 출력
XOR(1, 1)  # 0을 출력
```
![[Pasted image 20250626215230.png]]
보다시피 AND, OR가 단층 퍼셉트론인 데 반해, XOR는 2층 퍼셉트론이다 .이처럼 층이 여러 개인 퍼셉트론을 다층 퍼셉트론이라고 한다.
1. 0층의 두 뉴런이 입력 신호를 받아 1층의 뉴런으로 신호를 보낸다
2. 1층의 뉴런이 2층의 뉴런으로 신호를 보내고, 2층의 뉴런은 $y$를 출력한다
이상으로 2층 구조를 사용해 퍼셉트론으로 XOR 게이트를 구현할 수 있다. 정리하자면 **단층 퍼셉트론으로는 표현하지 못한 것을 층을 하나 늘려 구현**할 수 있다.
# 정리
## 1. 퍼셉트론의 기본 개념
- 퍼셉트론은 다수의 신호를 입력받아 하나의 신호를 출력하는 구조
- 입력 신호에 가중치를 곱하고, 그 합이 임계값을 넘으면 1을 출력
- 뉴런 또는 노드를 통해 신호가 전달되는 구조
## 2. 기본 논리 게이트 구현
- AND, OR, NAND 게이트는 단층 퍼셉트론으로 구현 가능
- 각 게이트는 서로 다른 가중치와 편향값을 사용하여 구현
- 이들은 모두 직선 하나로 영역을 나눌 수 있는 선형 영역에 속함
## 3. XOR 게이트와 퍼셉트론의 한계
- 단층 퍼셉트론으로는 XOR 게이트를 구현할 수 없음
- XOR는 비선형 영역을 필요로 하기 때문
- 이를 해결하기 위해 다층 퍼셉트론 구조가 필요
## 4. 다층 퍼셉트론을 통한 해결
- XOR 게이트는 AND, NAND, OR 게이트를 조합하여 구현 가능
- 2층 구조의 퍼셉트론으로 구현되며, 이는 단층 퍼셉트론의 한계를 극복
- 이를 통해 비선형 영역의 문제도 해결 가능함을 확인
이러한 퍼셉트론의 개념은 현대 딥러닝의 기초가 되었으며, 더 복잡한 신경망 구조의 근간이 되었다.