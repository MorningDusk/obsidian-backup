---
date: 2025-05-02
tags:
  - arrange
---
# 1. 배열 개념

같은 타입의 원소들을 효율적으로 관리할 수 있는 기본 자료형이다. 배열은 하나의 변수 이름으로 동일한 타입의 데이터를 그룹화하여 관리할 수 있고, 인덱스라는 것으로 원하는 데이터에 임의 접근할 수 있다.
## 배열 선언
배열은 `int a[10]`과 같이 **배열의 크기**를 추가로 명시한다.
```cpp
#include <iostream>

using namespace std;

int main() {
	int arr1[] = {1, 2, 3, 4, 5};  // 배열 내 원소: 1 2 3 4 5, 크기는 5
	// 첫 두 요소 초기화, 나머지는 0
	int arr2[5] = {1, 2};  // 배열 내 원소: 1 2 0 0 0
	// 모든 요소를 0으로 초기화
	int arr3[5] = {};  // 배열 내 원소: 0 0 0 0 0
	// 초기화 없이 선언 (초깃값은 정의하지 않음, 출력값은 불확정)
	int arr4[5];  // 배열 내 원소: 불확정 (쓰레기값)
	
	return 0;
}
```
## 배열과 차원
컴퓨터의 메모리의 구조는 1차원이므로 다차원 배열인 2차원, 3차원 배열도 실제로는 1차원 공간에 저장한다. **배열의 차원과는 무관하게 메모리에 연속 할당된다.**
### **배열의 접근 및 제어**
배열로 선언한 변수들은 메모리의 연속된 공간에 할당된다. 따라서 다음 코드를 보면 배열의 원소 간 주소값은 변수 크기만큼 차이 난다. 변수명 앞에 `&`을 붙이면 해당 변수의 주소값을 연산한다.
```cpp
#include <iostream>

using namespace std;

int main() {
	int intArray[3] = {1, 2, 3};
	double doubleArray[3] = {1.1, 2.2, 3.3};
	char charArray[3] = {'a', 'b', 'c'};
	
	// int 배열의 주소값
	&intArray[0];  // 0x7ffeeef7a8c0
	&intArray[1];  // 0x7ffeeef7a8c4
	&intArray[2];  // 0x7ffeeef7a8c8
	
	// double 배열의 주소값
	&doubleArray[0];  // 0x7ffeeef7a8b0
	&doubleArray[1];  // 0x7ffeeef7a8b8
	&doubleArray[2];  // 0x7ffeeef7a8c0
	
	// char 배열의 주소값
	&charArray[0];  // 0x7ffeeef7a8af
	&charArray[1];  // 0x7ffeeef7a8b0
	&charArray[2];  // 0x7ffeeef7a8b1
	
	return 0;
	
}
```
메모리 주소가 연속적이라는 특징이 있어 배열은 인덱스를 활용하여 특정 원소에 임의 접근(random access)할 수 있다.
![[Pasted image 20250603223424.png]]
### 2차원 배열
2차원 배열은 1차원 배열을 확장한 것이다
```cpp
#include <iostream>

using namespace std;

int main() {
	int arr[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};  // 2차원 배열 선언
	cout << arr[2][3] << endl;  // arr[2][3]에 저장된 값을 출력  / 12
	arr[2][3] = 15;  // arr[2][3]에 저장된 값을 15로 변경
	cout << arr[2][3] << endl;  // 변경된 값을 출력  / 15
	
	return 0;	
}
```
2차원 배열 데이터에 접근하는 방법은 1차원 배열과 비슷한데, 행과 열을 명시해 `[ ]` 연산자를 2개 연이어 사용한다는 점만 다르다.
``` cpp
#include <iostream>

using namespace std;

int main() {
	// 2행 3열 2차원 배열을 표현하는 배열 선언
	int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
	// 배열 출력을 확인하기 위한 코드
	for (int i = 0; i < 2; i++) {
		for (int j = 0; j < 3; j++)
			cout << arr[i][j] << " ";
		cout << endl;
	}
	
	return 0;
}
```
![[Pasted image 20250603223513.png]]
# 2. 배열의 효율성
## 배열 연산의 시간 복잡도
**배열은 임의 접근이라는 방법으로 배열의 모든 위치에 있는 데이터에 단 한 번에 접근할 수 있다. 따라서 데이터에 접근하기 위한 시간 복잡도는 O(1)이다.**
### 맨 뒤에 삽입할 경우
다음과 같은 배열이 있을 때 2를 추가한다고 하자. 맨 뒤에 삽입할 때는 `arr[3]`에 임의 접근을 바로 할 수 있으며 데이터를 삽입해도 다른 데이터 위치에 영향을 주지 않는다.
![[Pasted image 20250603223714.png]]
### 맨 앞에 삽입할 경우
이 경우 기존 데이터들을 뒤로 한 칸씩 밀어야 한다. 즉, 미는 연산이 필요하다. 시간 복잡도는 O(N)이다.
![[Pasted image 20250603223736.png]]
### 중간에 삽입할 경우
5 앞에 데이터를 삽입한다면 5 이후의 데이터를 뒤로 한 칸 밀어야 한다. **다시 말해 현재 삽입한 데이터 뒤에 데이터 개수만큼 미는 연산을 해야 한다.** 시간 복잡도는 O(N)이다.
![[Pasted image 20250603223759.png]]
## 배열을 선택할 때 고려할 점
1. **할당할 수 있는 메모리 크기를 확인해야 한다.** 배열로 표현하려는 데이터가 너무 많으면 런타임에서 배열 할당에 실패할 수 있다.
2. **중간에 데이터 삽입이 많은지 확인해야 한다.** 배열은 선형 구조이기 때문에 중간이나 처음에 데이터를 빈번하게 삽입하면 시간 복잡도가 높아져 실제 시험에서 시간 초과가 발생할 수 있다.
> [!info]
> C++로 코딩 테스트를 풀 때는 직접 배열을 사용하기보다 STL에서 제공하는 벡터를 사용할 것
# 3. 몸풀기 문제
## 1. 배열 정렬하기
권장 시간: 10분 | 권장 시간 복잡도: O(NlogN)
정수 배열 `arr`을 오름차순으로 정렬해서 반환하는 `solution()` 함수를 완성하세요
### 제약 조건
- `arr`의 길이는 2 이상 10^5 이하
- `arr`의 원소 값은 -100,000 이상 100,000 이하
### 입출력의 예

| arr                     | result                  |
| ----------------------- | ----------------------- |
| `[1, -5, 2, 4, 3]`      | `[-5, 1, 2, 3, 4]`      |
| `[2, 1, 1, 3, 2, 5, 4]` | `[1, 1, 2, 2, 3, 4, 5]` |
| `[6, 1, 7]`             | `[1, 6, 7]`             |

### 프로토타입
`vector<int> solution(vector<int> arr)`

---
### 문제 분석하고 풀기
제약 조건을 보면 데이터 개수는 최대 10^5이다. 즉, 제한 시간이 3초라면 O(N^2) 알고리즘은 사용할 수 없다. 만약 정수 벡터의 최대 길이가 10이라면 O(N^2) 알고리즘을 사용할 수 있다. 때문에 단순히 O(N^2) 정렬 알고리즘으로 정렬하면 통과할 수 없다. `sort()` 함수는 기존의 벡터값을 정렬된 상태로 변경한다.

```cpp
#include <vector>
#include <algorithm>

using namespace std;

vector<int> solution(vector<int> arr) {
	sort(arr.begin(), arr.end());

	return arr;
}
```
### 시간 복잡도 분석하기
N은 `arr`의 길이이므로 시간 복잡도는 O(NlogN)이다.

---
## 2. 배열 제어하기
권장 시간: 10분 | 권장 시간 복잡도: O(NlogN)
정수 배열 `lst`가 주어집니다. 배열의 중복값을 제거하고 배열 데이터를 내림차순으로 정렬해서 반환하는 `solution()` 함수를 구현하세요.
### 제약 조건
- `lst`의 길이는 2 이상 1,000 이하
- `lst`의 원소 값은 -100,000 이상 100,000 이하
### 입출력의 예

| lst                     | result            |
| ----------------------- | ----------------- |
| `[4, 2, 2, 1, 3, 4]`    | `[4, 3, 2, 1]`    |
| `[2, 1, 1, 3, 2, 5, 4]` | `[5, 4, 3, 2, 1]` |

### 프로토타입
`vector<int> solution(vector<int> lst)`

---
### 문제 분석하고 풀기
```cpp
#include <vector>
#include <algorithm>

using namespace std;

bool compare(int a, int b) {  // 정렬 기준 정의
	return a > b;
}

vector<int> solution(vector<int> lst) {
	sort(lst.begin(), lst.end(), compare);  // 내림차순으로 정렬
	lst.erase(unique(lst.begin(), lst.end()), lst.end());  // 중복값 제거
	
	return lst;
}
```
`sort()` 함수는 인수를 2개 사용하기도 하고 3개 사용하기도 한다. 인수를 2개 사용하면 정렬할 범위의 시작과 끝을 나타내지만 여기에 인수 하나를 추가해서 3개를 사용하면 마지막 인수는 정렬 기준이 된다. 여기서 정렬 기준을 `compare()` 함수로 정의했다. 이 함수는 `sort()` 함수에서 정렬 기준으로 활용한다. 구현한 `compare()` 함수는 앞의 숫자가 뒤의 숫자보다 클 때 참이므로 역순으로 정렬한다. `compare()` 함수를 `sort()` 함수의 마지막 인수로 활용해서 내림차순으로 정렬한다. `unique()`함수와 `erase()` 메서드를 활용해서 중복값을 제거한다.
### 시간 복잡도 분석하기
N은 `lst`의 길이다. `lst`의 중복 원소를 제거하는 데 걸리는 시간 복잡도는 O(N)이고, 이를 다시 정렬하는 데 걸리는 시간 복잡도는 O(NlogN)이므로 최종 시간 복잡도는 O(NlogN)이다.

---
# 4. 합격자가 되는 모의 테스트
## 3. 두 수를 뽑아서 더하기
정답률: 68% | 권장 시간: 30분 | 권장 시간 복잡도: O(N^2log(N^2)) | 출제: 월간 코드 챌린지
문제 URL: [https://school.programmers.co.kr/learn/courses/30/lessons/68644](https://school.programmers.co.kr/learn/courses/30/lessons/68644)
정수 배열 `numbers`가 주어집니다. `numbers`에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 `return` 하도록 `solution` 함수를 완성해주세요.
### 제약 조건
- numbers의 길이는 2 이상 100 이하
- numbers의 모든 수는 0 이상 100 이하
### 입출력의 예

| numbers       | result          |
| ------------- | --------------- |
| `[2,1,3,4,1]` | `[2,3,4,5,6,7]` |
| `[5,0,2,7]`   | `[2,5,7,9,12]`  |

### 프로토타입
`vector<int> solution(vector<int> numbers)`

---
### 문제 분석하고 풀기
숫자 벡터에서 서로 다른 두 수를 선택해서 더한 결과를 모두 구하고 오름차순으로 정렬해서 반환하면 된다. 다만 중복값을 허용하지 않는다. 자료구조 중 `set`은 중복값을 허용하지 않으므로 `set`을 사용하면 된다.
1. 벡터에서 두 수를 선택하는 모든 경우의 수를 구한다
2. 과정 1에서 구한 수를 새로운 벡터에 저장하고 중복값을 제거한다
3. 벡터를 오름차순으로 정렬하고 반환한다
![[Pasted image 20250603224420.png]]
```cpp
#include <set>
#include <vector>

using namespace std;

vector<int> solution(vector<int> numbers) {
    set<int> sum;  // 두 수의 합을 저장할 저장 공간 선언
    
    for (int i = 0; i < numbers.size(); ++i)  // 반복문을 수행하면서 두 수의 합을 저장
        for (int j = i + 1; j < numbers.size(); ++j)
            sum.insert(numbers[i] + numbers[j]);
    
    vector<int> answer(sum.begin(), sum.end());  // 반환 타입을 맞추기 위해 벡터로 변환
    return answer;
}
```
두 수의 합을 저장하기 위해 `set<int>`형 `sum`을 하나 선언한다. 반복문을 수행하면서 두 수의 합을 `sum`에 저장한다. 이미 중복값을 제거하고 자동 정렬했으므로 `sum`을 `vector<int>`형으로 새로 생성하고 이를 반환한다.
### 시간 복잡도 분석하기
N은 `numbers`의 길이이다. 이중 반복문을 통해 모든 원소에 대해 두 수의 합을 구하는 연산의 시간 복잡도는 O(N^2)이다. 이후 이를 `set`으로 만들 때 시간 복잡도는 O(N^2)이다. N^2개의 데이터를 `insert()`하므로 시간 복잡도는 O(N^2log(N))이 된다. 따라서 최종 시간 복잡도는 O(N^2log(N))이 된다.

---
## 4. 모의고사
정답률: 62% | 권장 시간: 30분 | 권장 시간 복잡도: O(N) | 출제: 완전 탐색
문제 URL: [https://school.programmers.co.kr/learn/courses/30/lessons/42840](https://school.programmers.co.kr/learn/courses/30/lessons/42840)
수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.
1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ... 
2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ... 
3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...
1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 `answers`가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 `return` 하도록 `solution` 함수를 작성해주세요.
### 제약 조건
- 시험은 최대 10,000 문제로 구성
- 문제의 정답은 1, 2, 3, 4, 5중 하나
- 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬
### 입출력의 예

| answers       | return    |
| ------------- | --------- |
| `[1,2,3,4,5]` | `[1]`     |
| `[1,3,2,4,2]` | `[1,2,3]` |

### 프로토타입
`vector<int> solution(vector<int> answers)`

---
### 문제 분석하고 풀기
가장 먼저 수포자들의 문제를 찍는 패턴을 분석해야 한다.
![[Pasted image 20250603224847.png]]
패턴을 찾았으니 각 패턴으로 문제를 풀 경우 몇 개를 맞출 수 있는지 체크한다. 문제 번호에 대해 수포자의 답과 실제 답이 일치할 때마다 점수를 획득하는데, 이 점수가 가장 큰 수포자를 찾는다. 예를 들어 답이 [1, 4, 2, 4, 2]인 경우 수포자 1, 수포자 2는 2문제를 맞췄고 수포자 3은 1문제를 맞춘다. 이 경우 최대 점수를 얻은 수포자는 수포자 1과 2이다.
![[Pasted image 20250603224928.png]]
만약 답이 [1, 3, 5, 4, 5, 2, 4, 5]이면 답의 길이가 8이고 수포자 1의 패턴 길이는 5이므로 답의 길이가 수포자 1의 패턴 길이보다 길다. 그런 경우 다음과 같이 코드를 설계해야 한다. [1, 2, 3, 4, 5]까지는 기존 방식으로 답안을 매치하면 되고 수포자 1과 같이 패턴 길이를 넘어서는 [2, 4, 5]는 수포자 1의 답 패턴 첫 번째부터 매치하면 된다.
![[Pasted image 20250603225003.png]]
### 모듈러 연산으로 반복 패턴 표현하기
코딩 테스트에서 빈번하게 나오는 패턴이며 이를 구현하는 가장 효율적인 방법은 나눗셈의 나머지를 활용하는 것이다. 특정 수를 N으로 나누면 나머지의 범위가 0 ~ (n-1)의 범위가 되는 걸 이용하는 것이다. 예를 들어서 N이 3이라면 다음과 같다.
![[Pasted image 20250603225123.png]]
이처럼 순차적으로 증가하는 정수를 N으로 나눴을 때 나머지는 (0 ~ (N-1))을 반복한다. 나머지를 구할 때는 모듈러 연산 `%`을 활용하면 된다.
``` cpp
#include <algorithm>
#include <string>
#include <vector>

using namespace std;

// 각 수포자가 찍는 패턴 정의
vector<int> firstPattern = {1, 2, 3, 4, 5};
vector<int> secondPattern = {2, 1, 2, 3, 2, 4, 2, 5};
vector<int> thirdPattern = {3, 3, 1, 1, 2, 2, 4, 4, 5, 5};

vector<int> solution(vector<int> answers) {
	vector<int> answer;  // 가장 많이 문제를 맞힌 사람이 저장될 벡터
	// 각 수포자들의 패턴대로 답안을 작성할 때 문제를 맞힌 개수를 저장할 벡터
	vector<int> matchCnt(3);
	// 실제 정답과 각 수포자들의 패턴을 비교해서 맞힌 개수
	for (int i = 0; i < answers.size(); i++) {
		if (answers[i] == firstPattern[i % firstPattern.size()])
			matchCnt[0]++;
		if (answers[i] == secondPattern[i % secondPattern.size()])
			matchCnt[1]++;
		if (answers[i] == thirdPattern[i % thirdPattern.size()])
			matchCnt[2]++;
	}
	
	// 가장 많이 맞힌 수포자가 얻은 점수
	int max_score = *max_element(matchCnt.begin(), matchCnt.end());
	// 가장 많이 맞힌 수포자의 번호를 저장
	for (int i = 0; i < 3; ++i)
		if (matchCnt[i] == max_score)
			answer.push_back(i + 1);
	
	return answer;
	
}
```
1. 먼저 3개의 벡터를 선언한다. 각 벡터는 수포자들이 문제를 푸는 패턴 정보를 가진다.
2. `answer`는 최종으로 가장 많이 정답을 맞힌 수포자의 번호를 오름차순으로 저장한다.
3. `matchCnt`는 각 수포자들의 패턴대로 문제를 풀 때, 수포자들이 맞힌 문제의 개수를 저장한다.
4. 각 문제의 정답과 수포자들의 패턴을 비교한다. 문항별 실제 정답과 수포자들의 패턴에 의해 작성된 답안을 비교해서 해당 수포자의 번호에 해당하는 값을 증가시킨다. 이는 정답을 맞힌 횟수를 세는 것이다. 여기서 앞서 요일로 이해한 `%`연산을 활용한다. 정답의 길이가 수포자의 패턴보다 길어도 다시 패턴의 처음으로 돌아가서 반복한다.
5. 각 수포자가 맞힌 정답의 개수 중 가장 큰 값이 `max_score`이다.
6. 가장 많이 맞힌 수포자의 번호를 `answer`에 저장한다. 낮은 번호의 수포자부터 비교하는 이유는 문제를 맞힌 개수가 같은 수포자가 있을 경우, 낮은 번호부터 추가해야 하는 제약 조건 때문이다.
### 시간 복잡도 분석하기
각 수포자들의 패턴과 정답을 비교하는 부분은 O(N)이다. 이후 `scores`를 순회하면서 가장 높은 점수를 받은 수포자를 추가하는 연산은 O(1)이다. 따라서 최종 시간 복잡도는 O(N)이다.

---
## 5. 행렬의 곱셈
정답률: 63% | 권장 시간: 40분 | 권장 시간 복잡도: O(N^3) | 출제: 연습문제
문제 URL: [https://school.programmers.co.kr/learn/courses/30/lessons/12949](https://school.programmers.co.kr/learn/courses/30/lessons/12949)
2차원 행렬 arr1과 arr2를 입력받아, arr1에 arr2를 곱한 결과를 반환하는 함수, solution을 완성해주세요.
### 제약 조건
- 행렬 arr1, arr2의 행과 열의 길이는 2 이상 100 이하
- 행렬 arr1, arr2의 원소는 -10 이상 20 이하인 자연수
- 곱할 수 있는 배열만 주어집니다.
### 입출력의 예

| arr1                                | arr2                                | return                                       |
| ----------------------------------- | ----------------------------------- | -------------------------------------------- |
| `[[1, 4], [3, 2], [4, 1]]`          | `[[3, 3], [3, 3]]`                  | `[[15, 15], [15, 15], [15, 15]]`             |
| `[[2, 3, 2], [4, 2, 4], [3, 1, 4]]` | `[[5, 4, 3], [2, 4, 1], [3, 1, 1]]` | `[[22, 22, 11], [36, 28, 18], [29, 20, 14]]` |

### 프로토타입
`vector<vector<int>> solution(vector<vector<int>> arr1, vector<vector<int>> arr2)`

---
### 문제 분석하고 풀기
수학의 행렬 곱셈을 그대로 구현하면 된다. 두 배열의 최대 데이터 개수가 100 * 100 = 10,000개이므로 시간 복잡도는 신경 쓰지 않아도 된다. 또한 행렬 곱할 수 있는 배열만 주어지므로 예외 처리도 없다.
```cpp
#include <string>
#include <vector>

using namespace std;

vector<vector<int>> solution(vector<vector<int>> arr1, vector<vector<int>> arr2) {
	// 최종 행렬 곱의 결과를 저장할 벡터 선언
	vector<vector<int>> answer;
	
	// arr1과 arr2의 행렬 곱을 수행했을 때 최종 행렬의 크기만큼 공간을 할당
	answer.assign(arr1.size(), vector<int>(arr2[1].size(), 0));
	
	// arr1의 각 행과 arr2의 각 열에 대해 반복문 수행
	for (int i = 0; i < arr1.size(); i++) 
		for (int j = 0; j < arr2[1].size(); j++)
			for (int k = 0; k < arr2.size(); k++)
				answer[i][j] += arr1[i][k] * arr2[k][j];  // 두 행렬의 곱을 수행
				
	return answer;
}
```

가장 먼저 행렬 곱셈의 결과값을 어떻게 저장할지 고려해야 한다. 결괏값을 저장하려면 두 행렬을 곱했을 때 결과 행렬의 크기를 알아야 한다.
1. 최종 행렬 곱이 저장될 벡터를 선언한다. `vector<vector<int>> answer`를 보면 `answer`는 벡터이다. 그리고 이 벡터의 타입은 `vector<int>` 이다. 즉 각 원소가 `vector<int>` 인 벡터라고 보면 된다.
2. `answer`를 2차원 정적 배열처럼 사용할 것이다. 행렬 곱을 저장할 수 있도록 `answer`에 메모리를 할당한다. 벡터를 내부에서 동적으로 저장 공간을 관리하기 때문에 현재 코드처럼 임의 접근을 하려면 필요한 역량을 미리 할당해줘야 예외가 발생하지 않는다. 행렬 곱을 수행하면서 `answer`의 특정 위치에 결괏값을 저장하려고 할 때 할당되지 않은 공간에 접근하지 않도록 `assign()` 메서드를 활용해서 필요한 공간을 미리 할당한다.
3. 행렬 곱을 수행하기 위해 `arr1` 의 각 행을 차례대로 순회한다. 내부 반복문은 `arr2` 각 열을 차례대로 순회한다.
4. `arr1`의 `arr2` 의 열의 값을 곱하여 `answer`에 저장한다.
### 시간 복잡도 분석하기
행과 열의 길이는 같다. `arr1` 의 행과 열 수를 r1, c1라고 하고 `arr2`의 행과 열 수를 r2, c2라고 했을 때 r1_c1_c2만큼 연산한다. r1, c1, r2, c2 모두 N으로 볼 수 있으므로 최종 시간 복잡도는 O(N^3)이다.

---
## 6. 실패율
정답률: 60% | 권장 시간: 60분 | 권장 시간 복잡도: O(M+NlogN) | 출제: 2019 KAKAO BLIND RECRUITMENT
문제 URL: [https://school.programmers.co.kr/learn/courses/30/lessons/42889](https://school.programmers.co.kr/learn/courses/30/lessons/42889)
슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.
이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.
- 실패율은 다음과 같이 정의한다.
    - 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수
전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 `stages`가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 `return` 하도록 `solution` 함수를 완성하라.
### 제약 조건
- 스테이지의 개수 N은 `1` 이상 `500` 이하의 자연수이다.
- stages의 길이는 `1` 이상 `200,000` 이하이다.
- stages에는 `1` 이상 `N + 1` 이하의 자연수가 담겨있다.
    - 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다.
    - 단, `N + 1` 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다.
- 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.
- 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 `0` 으로 정의한다.
### 입출력의 예

| N   | stages                     | result        |
| --- | -------------------------- | ------------- |
| 5   | `[2, 1, 2, 6, 2, 4, 3, 3]` | `[3,4,2,1,5]` |
| 4   | `[4,4,4,4,4]`              | `[4,1,2,3]`   |

입출력 예 #1
1번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다.
- 1 번 스테이지 실패율 : 1/8
2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다.
- 2 번 스테이지 실패율 : 3/7
마찬가지로 나머지 스테이지의 실패율은 다음과 같다.
- 3 번 스테이지 실패율 : 2/4
- 4번 스테이지 실패율 : 1/2
- 5번 스테이지 실패율 : 0/1
각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다.
- `[3,4,2,1,5]`

입출력 예 #2
모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다.
- `[4,1,2,3]`

### 프로토타입
`vector<int> solution(int N, vector<int> stages)`

---
### 문제 분석하고 풀기
실패율이란 해당 스테이지에 도달한 적 있는 사용자 중 아직 클리어하지 못한 사용자의 비율을 말한다.
![[Pasted image 20250603225849.png]]
